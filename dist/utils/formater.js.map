{"version":3,"file":"formater.js","sourceRoot":"","sources":["../../src/utils/formater.ts"],"names":[],"mappings":"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","sourcesContent":["// Add near the top of the file (after imports) --------------------------------\nexport type CaseStyle =\n  | \"lower\"\n  | \"upper\"\n  | \"kebab\"\n  | \"snake\"\n  | \"camel\"\n  | \"pascal\"\n  | \"none\";\n\nexport interface FormatOptions {\n  // separator between adjective and noun (or parts of the token)\n  sep?: string;\n  // casing transformation to apply after joining\n  case?: CaseStyle;\n  // optional prefix and suffix\n  prefix?: string;\n  suffix?: string;\n  // when using UUID/hex tokens, how many characters to keep from the token segment\n  tokenLength?: number;\n  // if true, remove the hyphen that generateDefault uses (or use sep when provided)\n  useUUID?: boolean;\n}\n\n// small utility to convert strings to camel/pascal/etc.\nfunction applyCase(s: string, style?: CaseStyle): string {\n  if (!style || style === \"none\") return s;\n  if (style === \"lower\") return s.toLowerCase();\n  if (style === \"upper\") return s.toUpperCase();\n  // normalize: split on non-alphanum and on hyphen/underscore\n  const parts = s.split(/[^A-Za-z0-9]+/).filter(Boolean);\n  if (style === \"kebab\") return parts.map((p) => p.toLowerCase()).join(\"-\");\n  if (style === \"snake\") return parts.map((p) => p.toLowerCase()).join(\"_\");\n  if (style === \"camel\") {\n    return parts\n      .map((p, i) =>\n        i === 0\n          ? p.toLowerCase()\n          : p.charAt(0).toUpperCase() + p.slice(1).toLowerCase(),\n      )\n      .join(\"\");\n  }\n  if (style === \"pascal\") {\n    return parts\n      .map((p) => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase())\n      .join(\"\");\n  }\n  return s;\n}\n\n// format a generated base string according to options\nexport function formatPseudoe(base: string, opts?: FormatOptions): string {\n  const o: FormatOptions = opts || {};\n  // If a tokenLength was requested and the base contains sections, apply to the last part.\n  if (typeof o.tokenLength === \"number\" && o.tokenLength > 0) {\n    // apply tokenLength to last hyphen/sep segment if present\n    const parts = base.split(/[-_ ]+/);\n    const last = parts[parts.length - 1];\n    if (last && last.length > o.tokenLength) {\n      parts[parts.length - 1] = last.slice(0, o.tokenLength);\n      base = parts.join(o.sep ?? \"-\");\n    }\n  }\n\n  // If a specific sep was requested, replace default separators with the requested one\n  if (o.sep !== undefined) {\n    // replace any common separators with the requested one\n    base = base.replace(/[-_\\s]+/g, o.sep);\n  }\n\n  // apply casing last (so separators are applied first)\n  const cased = applyCase(base, o.case);\n\n  // add prefix / suffix\n  const pref = o.prefix ?? \"\";\n  const suf = o.suffix ?? \"\";\n  return `${pref}${cased}${suf}`;\n}\n"]}